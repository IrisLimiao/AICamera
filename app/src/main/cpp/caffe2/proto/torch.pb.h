// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe2/proto/torch.proto

#ifndef PROTOBUF_caffe2_2fproto_2ftorch_2eproto__INCLUDED
#define PROTOBUF_caffe2_2fproto_2ftorch_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "caffe2/proto/caffe2.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_caffe2_2fproto_2ftorch_2eproto {
// Internal implementation detail -- do not use these members.
struct CAFFE2_API TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void CAFFE2_API AddDescriptors();
void CAFFE2_API InitDefaultsParameterDefImpl();
void CAFFE2_API InitDefaultsParameterDef();
void CAFFE2_API InitDefaultsMethodDefImpl();
void CAFFE2_API InitDefaultsMethodDef();
void CAFFE2_API InitDefaultsModuleDefImpl();
void CAFFE2_API InitDefaultsModuleDef();
void CAFFE2_API InitDefaultsModelDefImpl();
void CAFFE2_API InitDefaultsModelDef();
inline void CAFFE2_API InitDefaults() {
  InitDefaultsParameterDef();
  InitDefaultsMethodDef();
  InitDefaultsModuleDef();
  InitDefaultsModelDef();
}
}  // namespace protobuf_caffe2_2fproto_2ftorch_2eproto
namespace torch { const ::std::string& GetEmptyStringAlreadyInited(); 
class MethodDef;
class MethodDefDefaultTypeInternal;
CAFFE2_API extern MethodDefDefaultTypeInternal _MethodDef_default_instance_;
class ModelDef;
class ModelDefDefaultTypeInternal;
CAFFE2_API extern ModelDefDefaultTypeInternal _ModelDef_default_instance_;
class ModuleDef;
class ModuleDefDefaultTypeInternal;
CAFFE2_API extern ModuleDefDefaultTypeInternal _ModuleDef_default_instance_;
class ParameterDef;
class ParameterDefDefaultTypeInternal;
CAFFE2_API extern ParameterDefDefaultTypeInternal _ParameterDef_default_instance_;
}  // namespace torch
namespace torch {

enum ProtoVersion {
  PROTO_VERSION_NEWEST = 1
};
CAFFE2_API bool ProtoVersion_IsValid(int value);
const ProtoVersion ProtoVersion_MIN = PROTO_VERSION_NEWEST;
const ProtoVersion ProtoVersion_MAX = PROTO_VERSION_NEWEST;
const int ProtoVersion_ARRAYSIZE = ProtoVersion_MAX + 1;

CAFFE2_API const ::google::protobuf::EnumDescriptor* ProtoVersion_descriptor();
inline const ::std::string& ProtoVersion_Name(ProtoVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtoVersion_descriptor(), value);
}
inline bool ProtoVersion_Parse(
    const ::std::string& name, ProtoVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtoVersion>(
    ProtoVersion_descriptor(), name, value);
}
// ===================================================================

class CAFFE2_API ParameterDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:torch.ParameterDef) */ {
 public:
  ParameterDef();
  virtual ~ParameterDef();

  ParameterDef(const ParameterDef& from);

  inline ParameterDef& operator=(const ParameterDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParameterDef(ParameterDef&& from) noexcept
    : ParameterDef() {
    *this = ::std::move(from);
  }

  inline ParameterDef& operator=(ParameterDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParameterDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParameterDef* internal_default_instance() {
    return reinterpret_cast<const ParameterDef*>(
               &_ParameterDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    0;

  void Swap(ParameterDef* other);
  friend void swap(ParameterDef& a, ParameterDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParameterDef* New() const PROTOBUF_FINAL { return New(NULL); }

  ParameterDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParameterDef& from);
  void MergeFrom(const ParameterDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParameterDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .caffe2.TensorProto tensor = 3;
  bool has_tensor() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 3;
  const ::caffe2::TensorProto& tensor() const;
  ::caffe2::TensorProto* release_tensor();
  ::caffe2::TensorProto* mutable_tensor();
  void set_allocated_tensor(::caffe2::TensorProto* tensor);

  // optional bool require_gradient = 1;
  bool has_require_gradient() const;
  void clear_require_gradient();
  static const int kRequireGradientFieldNumber = 1;
  bool require_gradient() const;
  void set_require_gradient(bool value);

  // optional bool is_buffer = 2;
  bool has_is_buffer() const;
  void clear_is_buffer();
  static const int kIsBufferFieldNumber = 2;
  bool is_buffer() const;
  void set_is_buffer(bool value);

  // @@protoc_insertion_point(class_scope:torch.ParameterDef)
 private:
  void set_has_require_gradient();
  void clear_has_require_gradient();
  void set_has_is_buffer();
  void clear_has_is_buffer();
  void set_has_tensor();
  void clear_has_tensor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::caffe2::TensorProto* tensor_;
  bool require_gradient_;
  bool is_buffer_;
  friend struct ::protobuf_caffe2_2fproto_2ftorch_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2ftorch_2eproto::InitDefaultsParameterDefImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API MethodDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:torch.MethodDef) */ {
 public:
  MethodDef();
  virtual ~MethodDef();

  MethodDef(const MethodDef& from);

  inline MethodDef& operator=(const MethodDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MethodDef(MethodDef&& from) noexcept
    : MethodDef() {
    *this = ::std::move(from);
  }

  inline MethodDef& operator=(MethodDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MethodDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MethodDef* internal_default_instance() {
    return reinterpret_cast<const MethodDef*>(
               &_MethodDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    1;

  void Swap(MethodDef* other);
  friend void swap(MethodDef& a, MethodDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MethodDef* New() const PROTOBUF_FINAL { return New(NULL); }

  MethodDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MethodDef& from);
  void MergeFrom(const MethodDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MethodDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string torch_script = 3;
  bool has_torch_script() const;
  void clear_torch_script();
  static const int kTorchScriptFieldNumber = 3;
  const ::std::string& torch_script() const;
  void set_torch_script(const ::std::string& value);
  #if LANG_CXX11
  void set_torch_script(::std::string&& value);
  #endif
  void set_torch_script(const char* value);
  void set_torch_script(const char* value, size_t size);
  ::std::string* mutable_torch_script();
  ::std::string* release_torch_script();
  void set_allocated_torch_script(::std::string* torch_script);

  // optional .caffe2.NetDef graph = 2;
  bool has_graph() const;
  void clear_graph();
  static const int kGraphFieldNumber = 2;
  const ::caffe2::NetDef& graph() const;
  ::caffe2::NetDef* release_graph();
  ::caffe2::NetDef* mutable_graph();
  void set_allocated_graph(::caffe2::NetDef* graph);

  // @@protoc_insertion_point(class_scope:torch.MethodDef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_graph();
  void clear_has_graph();
  void set_has_torch_script();
  void clear_has_torch_script();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr torch_script_;
  ::caffe2::NetDef* graph_;
  friend struct ::protobuf_caffe2_2fproto_2ftorch_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2ftorch_2eproto::InitDefaultsMethodDefImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API ModuleDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:torch.ModuleDef) */ {
 public:
  ModuleDef();
  virtual ~ModuleDef();

  ModuleDef(const ModuleDef& from);

  inline ModuleDef& operator=(const ModuleDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleDef(ModuleDef&& from) noexcept
    : ModuleDef() {
    *this = ::std::move(from);
  }

  inline ModuleDef& operator=(ModuleDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleDef* internal_default_instance() {
    return reinterpret_cast<const ModuleDef*>(
               &_ModuleDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    2;

  void Swap(ModuleDef* other);
  friend void swap(ModuleDef& a, ModuleDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleDef* New() const PROTOBUF_FINAL { return New(NULL); }

  ModuleDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModuleDef& from);
  void MergeFrom(const ModuleDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModuleDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .torch.ModuleDef submodules = 1;
  int submodules_size() const;
  void clear_submodules();
  static const int kSubmodulesFieldNumber = 1;
  const ::torch::ModuleDef& submodules(int index) const;
  ::torch::ModuleDef* mutable_submodules(int index);
  ::torch::ModuleDef* add_submodules();
  ::google::protobuf::RepeatedPtrField< ::torch::ModuleDef >*
      mutable_submodules();
  const ::google::protobuf::RepeatedPtrField< ::torch::ModuleDef >&
      submodules() const;

  // repeated .torch.MethodDef methods = 2;
  int methods_size() const;
  void clear_methods();
  static const int kMethodsFieldNumber = 2;
  const ::torch::MethodDef& methods(int index) const;
  ::torch::MethodDef* mutable_methods(int index);
  ::torch::MethodDef* add_methods();
  ::google::protobuf::RepeatedPtrField< ::torch::MethodDef >*
      mutable_methods();
  const ::google::protobuf::RepeatedPtrField< ::torch::MethodDef >&
      methods() const;

  // repeated .torch.ParameterDef parameters = 5;
  int parameters_size() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 5;
  const ::torch::ParameterDef& parameters(int index) const;
  ::torch::ParameterDef* mutable_parameters(int index);
  ::torch::ParameterDef* add_parameters();
  ::google::protobuf::RepeatedPtrField< ::torch::ParameterDef >*
      mutable_parameters();
  const ::google::protobuf::RepeatedPtrField< ::torch::ParameterDef >&
      parameters() const;

  // optional bytes pickle_arena = 3;
  bool has_pickle_arena() const;
  void clear_pickle_arena();
  static const int kPickleArenaFieldNumber = 3;
  const ::std::string& pickle_arena() const;
  void set_pickle_arena(const ::std::string& value);
  #if LANG_CXX11
  void set_pickle_arena(::std::string&& value);
  #endif
  void set_pickle_arena(const char* value);
  void set_pickle_arena(const void* value, size_t size);
  ::std::string* mutable_pickle_arena();
  ::std::string* release_pickle_arena();
  void set_allocated_pickle_arena(::std::string* pickle_arena);

  // optional bytes cpp_arena = 4;
  bool has_cpp_arena() const;
  void clear_cpp_arena();
  static const int kCppArenaFieldNumber = 4;
  const ::std::string& cpp_arena() const;
  void set_cpp_arena(const ::std::string& value);
  #if LANG_CXX11
  void set_cpp_arena(::std::string&& value);
  #endif
  void set_cpp_arena(const char* value);
  void set_cpp_arena(const void* value, size_t size);
  ::std::string* mutable_cpp_arena();
  ::std::string* release_cpp_arena();
  void set_allocated_cpp_arena(::std::string* cpp_arena);

  // @@protoc_insertion_point(class_scope:torch.ModuleDef)
 private:
  void set_has_pickle_arena();
  void clear_has_pickle_arena();
  void set_has_cpp_arena();
  void clear_has_cpp_arena();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::torch::ModuleDef > submodules_;
  ::google::protobuf::RepeatedPtrField< ::torch::MethodDef > methods_;
  ::google::protobuf::RepeatedPtrField< ::torch::ParameterDef > parameters_;
  ::google::protobuf::internal::ArenaStringPtr pickle_arena_;
  ::google::protobuf::internal::ArenaStringPtr cpp_arena_;
  friend struct ::protobuf_caffe2_2fproto_2ftorch_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2ftorch_2eproto::InitDefaultsModuleDefImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API ModelDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:torch.ModelDef) */ {
 public:
  ModelDef();
  virtual ~ModelDef();

  ModelDef(const ModelDef& from);

  inline ModelDef& operator=(const ModelDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelDef(ModelDef&& from) noexcept
    : ModelDef() {
    *this = ::std::move(from);
  }

  inline ModelDef& operator=(ModelDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelDef* internal_default_instance() {
    return reinterpret_cast<const ModelDef*>(
               &_ModelDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    3;

  void Swap(ModelDef* other);
  friend void swap(ModelDef& a, ModelDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelDef* New() const PROTOBUF_FINAL { return New(NULL); }

  ModelDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModelDef& from);
  void MergeFrom(const ModelDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModelDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe2.Argument annotations = 6;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 6;
  const ::caffe2::Argument& annotations(int index) const;
  ::caffe2::Argument* mutable_annotations(int index);
  ::caffe2::Argument* add_annotations();
  ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >*
      mutable_annotations();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >&
      annotations() const;

  // optional string producer_name = 3;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 3;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  #if LANG_CXX11
  void set_producer_name(::std::string&& value);
  #endif
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional string producer_version = 4;
  bool has_producer_version() const;
  void clear_producer_version();
  static const int kProducerVersionFieldNumber = 4;
  const ::std::string& producer_version() const;
  void set_producer_version(const ::std::string& value);
  #if LANG_CXX11
  void set_producer_version(::std::string&& value);
  #endif
  void set_producer_version(const char* value);
  void set_producer_version(const char* value, size_t size);
  ::std::string* mutable_producer_version();
  ::std::string* release_producer_version();
  void set_allocated_producer_version(::std::string* producer_version);

  // optional string name = 5;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .torch.ModuleDef main_module = 2;
  bool has_main_module() const;
  void clear_main_module();
  static const int kMainModuleFieldNumber = 2;
  const ::torch::ModuleDef& main_module() const;
  ::torch::ModuleDef* release_main_module();
  ::torch::ModuleDef* mutable_main_module();
  void set_allocated_main_module(::torch::ModuleDef* main_module);

  // optional int64 proto_version = 1;
  bool has_proto_version() const;
  void clear_proto_version();
  static const int kProtoVersionFieldNumber = 1;
  ::google::protobuf::int64 proto_version() const;
  void set_proto_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:torch.ModelDef)
 private:
  void set_has_proto_version();
  void clear_has_proto_version();
  void set_has_main_module();
  void clear_has_main_module();
  void set_has_producer_name();
  void clear_has_producer_name();
  void set_has_producer_version();
  void clear_has_producer_version();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::Argument > annotations_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::internal::ArenaStringPtr producer_version_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::torch::ModuleDef* main_module_;
  ::google::protobuf::int64 proto_version_;
  friend struct ::protobuf_caffe2_2fproto_2ftorch_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2ftorch_2eproto::InitDefaultsModelDefImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ParameterDef

// optional bool require_gradient = 1;
inline bool ParameterDef::has_require_gradient() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParameterDef::set_has_require_gradient() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParameterDef::clear_has_require_gradient() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParameterDef::clear_require_gradient() {
  require_gradient_ = false;
  clear_has_require_gradient();
}
inline bool ParameterDef::require_gradient() const {
  // @@protoc_insertion_point(field_get:torch.ParameterDef.require_gradient)
  return require_gradient_;
}
inline void ParameterDef::set_require_gradient(bool value) {
  set_has_require_gradient();
  require_gradient_ = value;
  // @@protoc_insertion_point(field_set:torch.ParameterDef.require_gradient)
}

// optional bool is_buffer = 2;
inline bool ParameterDef::has_is_buffer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParameterDef::set_has_is_buffer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParameterDef::clear_has_is_buffer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParameterDef::clear_is_buffer() {
  is_buffer_ = false;
  clear_has_is_buffer();
}
inline bool ParameterDef::is_buffer() const {
  // @@protoc_insertion_point(field_get:torch.ParameterDef.is_buffer)
  return is_buffer_;
}
inline void ParameterDef::set_is_buffer(bool value) {
  set_has_is_buffer();
  is_buffer_ = value;
  // @@protoc_insertion_point(field_set:torch.ParameterDef.is_buffer)
}

// optional .caffe2.TensorProto tensor = 3;
inline bool ParameterDef::has_tensor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParameterDef::set_has_tensor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParameterDef::clear_has_tensor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::caffe2::TensorProto& ParameterDef::tensor() const {
  const ::caffe2::TensorProto* p = tensor_;
  // @@protoc_insertion_point(field_get:torch.ParameterDef.tensor)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::TensorProto*>(
      &::caffe2::_TensorProto_default_instance_);
}
inline ::caffe2::TensorProto* ParameterDef::release_tensor() {
  // @@protoc_insertion_point(field_release:torch.ParameterDef.tensor)
  clear_has_tensor();
  ::caffe2::TensorProto* temp = tensor_;
  tensor_ = NULL;
  return temp;
}
inline ::caffe2::TensorProto* ParameterDef::mutable_tensor() {
  set_has_tensor();
  if (tensor_ == NULL) {
    tensor_ = new ::caffe2::TensorProto;
  }
  // @@protoc_insertion_point(field_mutable:torch.ParameterDef.tensor)
  return tensor_;
}
inline void ParameterDef::set_allocated_tensor(::caffe2::TensorProto* tensor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tensor_);
  }
  if (tensor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tensor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    set_has_tensor();
  } else {
    clear_has_tensor();
  }
  tensor_ = tensor;
  // @@protoc_insertion_point(field_set_allocated:torch.ParameterDef.tensor)
}

// -------------------------------------------------------------------

// MethodDef

// optional string name = 1;
inline bool MethodDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MethodDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MethodDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MethodDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MethodDef::name() const {
  // @@protoc_insertion_point(field_get:torch.MethodDef.name)
  return name_.GetNoArena();
}
inline void MethodDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.MethodDef.name)
}
#if LANG_CXX11
inline void MethodDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.MethodDef.name)
}
#endif
inline void MethodDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.MethodDef.name)
}
inline void MethodDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.MethodDef.name)
}
inline ::std::string* MethodDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:torch.MethodDef.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* MethodDef::release_name() {
  // @@protoc_insertion_point(field_release:torch.MethodDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void MethodDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:torch.MethodDef.name)
}

// optional .caffe2.NetDef graph = 2;
inline bool MethodDef::has_graph() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MethodDef::set_has_graph() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MethodDef::clear_has_graph() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::caffe2::NetDef& MethodDef::graph() const {
  const ::caffe2::NetDef* p = graph_;
  // @@protoc_insertion_point(field_get:torch.MethodDef.graph)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::NetDef*>(
      &::caffe2::_NetDef_default_instance_);
}
inline ::caffe2::NetDef* MethodDef::release_graph() {
  // @@protoc_insertion_point(field_release:torch.MethodDef.graph)
  clear_has_graph();
  ::caffe2::NetDef* temp = graph_;
  graph_ = NULL;
  return temp;
}
inline ::caffe2::NetDef* MethodDef::mutable_graph() {
  set_has_graph();
  if (graph_ == NULL) {
    graph_ = new ::caffe2::NetDef;
  }
  // @@protoc_insertion_point(field_mutable:torch.MethodDef.graph)
  return graph_;
}
inline void MethodDef::set_allocated_graph(::caffe2::NetDef* graph) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(graph_);
  }
  if (graph) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      graph = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    set_has_graph();
  } else {
    clear_has_graph();
  }
  graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:torch.MethodDef.graph)
}

// optional string torch_script = 3;
inline bool MethodDef::has_torch_script() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MethodDef::set_has_torch_script() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MethodDef::clear_has_torch_script() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MethodDef::clear_torch_script() {
  torch_script_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_torch_script();
}
inline const ::std::string& MethodDef::torch_script() const {
  // @@protoc_insertion_point(field_get:torch.MethodDef.torch_script)
  return torch_script_.GetNoArena();
}
inline void MethodDef::set_torch_script(const ::std::string& value) {
  set_has_torch_script();
  torch_script_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.MethodDef.torch_script)
}
#if LANG_CXX11
inline void MethodDef::set_torch_script(::std::string&& value) {
  set_has_torch_script();
  torch_script_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.MethodDef.torch_script)
}
#endif
inline void MethodDef::set_torch_script(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_torch_script();
  torch_script_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.MethodDef.torch_script)
}
inline void MethodDef::set_torch_script(const char* value, size_t size) {
  set_has_torch_script();
  torch_script_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.MethodDef.torch_script)
}
inline ::std::string* MethodDef::mutable_torch_script() {
  set_has_torch_script();
  // @@protoc_insertion_point(field_mutable:torch.MethodDef.torch_script)
  return torch_script_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* MethodDef::release_torch_script() {
  // @@protoc_insertion_point(field_release:torch.MethodDef.torch_script)
  clear_has_torch_script();
  return torch_script_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void MethodDef::set_allocated_torch_script(::std::string* torch_script) {
  if (torch_script != NULL) {
    set_has_torch_script();
  } else {
    clear_has_torch_script();
  }
  torch_script_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), torch_script);
  // @@protoc_insertion_point(field_set_allocated:torch.MethodDef.torch_script)
}

// -------------------------------------------------------------------

// ModuleDef

// repeated .torch.ModuleDef submodules = 1;
inline int ModuleDef::submodules_size() const {
  return submodules_.size();
}
inline void ModuleDef::clear_submodules() {
  submodules_.Clear();
}
inline const ::torch::ModuleDef& ModuleDef::submodules(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.submodules)
  return submodules_.Get(index);
}
inline ::torch::ModuleDef* ModuleDef::mutable_submodules(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.submodules)
  return submodules_.Mutable(index);
}
inline ::torch::ModuleDef* ModuleDef::add_submodules() {
  // @@protoc_insertion_point(field_add:torch.ModuleDef.submodules)
  return submodules_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::torch::ModuleDef >*
ModuleDef::mutable_submodules() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModuleDef.submodules)
  return &submodules_;
}
inline const ::google::protobuf::RepeatedPtrField< ::torch::ModuleDef >&
ModuleDef::submodules() const {
  // @@protoc_insertion_point(field_list:torch.ModuleDef.submodules)
  return submodules_;
}

// repeated .torch.MethodDef methods = 2;
inline int ModuleDef::methods_size() const {
  return methods_.size();
}
inline void ModuleDef::clear_methods() {
  methods_.Clear();
}
inline const ::torch::MethodDef& ModuleDef::methods(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.methods)
  return methods_.Get(index);
}
inline ::torch::MethodDef* ModuleDef::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.methods)
  return methods_.Mutable(index);
}
inline ::torch::MethodDef* ModuleDef::add_methods() {
  // @@protoc_insertion_point(field_add:torch.ModuleDef.methods)
  return methods_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::torch::MethodDef >*
ModuleDef::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModuleDef.methods)
  return &methods_;
}
inline const ::google::protobuf::RepeatedPtrField< ::torch::MethodDef >&
ModuleDef::methods() const {
  // @@protoc_insertion_point(field_list:torch.ModuleDef.methods)
  return methods_;
}

// optional bytes pickle_arena = 3;
inline bool ModuleDef::has_pickle_arena() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleDef::set_has_pickle_arena() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleDef::clear_has_pickle_arena() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleDef::clear_pickle_arena() {
  pickle_arena_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_pickle_arena();
}
inline const ::std::string& ModuleDef::pickle_arena() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.pickle_arena)
  return pickle_arena_.GetNoArena();
}
inline void ModuleDef::set_pickle_arena(const ::std::string& value) {
  set_has_pickle_arena();
  pickle_arena_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.ModuleDef.pickle_arena)
}
#if LANG_CXX11
inline void ModuleDef::set_pickle_arena(::std::string&& value) {
  set_has_pickle_arena();
  pickle_arena_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModuleDef.pickle_arena)
}
#endif
inline void ModuleDef::set_pickle_arena(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pickle_arena();
  pickle_arena_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModuleDef.pickle_arena)
}
inline void ModuleDef::set_pickle_arena(const void* value, size_t size) {
  set_has_pickle_arena();
  pickle_arena_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModuleDef.pickle_arena)
}
inline ::std::string* ModuleDef::mutable_pickle_arena() {
  set_has_pickle_arena();
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.pickle_arena)
  return pickle_arena_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ModuleDef::release_pickle_arena() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.pickle_arena)
  clear_has_pickle_arena();
  return pickle_arena_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModuleDef::set_allocated_pickle_arena(::std::string* pickle_arena) {
  if (pickle_arena != NULL) {
    set_has_pickle_arena();
  } else {
    clear_has_pickle_arena();
  }
  pickle_arena_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), pickle_arena);
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.pickle_arena)
}

// optional bytes cpp_arena = 4;
inline bool ModuleDef::has_cpp_arena() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModuleDef::set_has_cpp_arena() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModuleDef::clear_has_cpp_arena() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModuleDef::clear_cpp_arena() {
  cpp_arena_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_cpp_arena();
}
inline const ::std::string& ModuleDef::cpp_arena() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.cpp_arena)
  return cpp_arena_.GetNoArena();
}
inline void ModuleDef::set_cpp_arena(const ::std::string& value) {
  set_has_cpp_arena();
  cpp_arena_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.ModuleDef.cpp_arena)
}
#if LANG_CXX11
inline void ModuleDef::set_cpp_arena(::std::string&& value) {
  set_has_cpp_arena();
  cpp_arena_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModuleDef.cpp_arena)
}
#endif
inline void ModuleDef::set_cpp_arena(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cpp_arena();
  cpp_arena_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModuleDef.cpp_arena)
}
inline void ModuleDef::set_cpp_arena(const void* value, size_t size) {
  set_has_cpp_arena();
  cpp_arena_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModuleDef.cpp_arena)
}
inline ::std::string* ModuleDef::mutable_cpp_arena() {
  set_has_cpp_arena();
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.cpp_arena)
  return cpp_arena_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ModuleDef::release_cpp_arena() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.cpp_arena)
  clear_has_cpp_arena();
  return cpp_arena_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModuleDef::set_allocated_cpp_arena(::std::string* cpp_arena) {
  if (cpp_arena != NULL) {
    set_has_cpp_arena();
  } else {
    clear_has_cpp_arena();
  }
  cpp_arena_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), cpp_arena);
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.cpp_arena)
}

// repeated .torch.ParameterDef parameters = 5;
inline int ModuleDef::parameters_size() const {
  return parameters_.size();
}
inline void ModuleDef::clear_parameters() {
  parameters_.Clear();
}
inline const ::torch::ParameterDef& ModuleDef::parameters(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.parameters)
  return parameters_.Get(index);
}
inline ::torch::ParameterDef* ModuleDef::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.parameters)
  return parameters_.Mutable(index);
}
inline ::torch::ParameterDef* ModuleDef::add_parameters() {
  // @@protoc_insertion_point(field_add:torch.ModuleDef.parameters)
  return parameters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::torch::ParameterDef >*
ModuleDef::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModuleDef.parameters)
  return &parameters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::torch::ParameterDef >&
ModuleDef::parameters() const {
  // @@protoc_insertion_point(field_list:torch.ModuleDef.parameters)
  return parameters_;
}

// -------------------------------------------------------------------

// ModelDef

// optional int64 proto_version = 1;
inline bool ModelDef::has_proto_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModelDef::set_has_proto_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModelDef::clear_has_proto_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModelDef::clear_proto_version() {
  proto_version_ = GOOGLE_LONGLONG(0);
  clear_has_proto_version();
}
inline ::google::protobuf::int64 ModelDef::proto_version() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.proto_version)
  return proto_version_;
}
inline void ModelDef::set_proto_version(::google::protobuf::int64 value) {
  set_has_proto_version();
  proto_version_ = value;
  // @@protoc_insertion_point(field_set:torch.ModelDef.proto_version)
}

// optional .torch.ModuleDef main_module = 2;
inline bool ModelDef::has_main_module() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModelDef::set_has_main_module() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModelDef::clear_has_main_module() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModelDef::clear_main_module() {
  if (main_module_ != NULL) main_module_->Clear();
  clear_has_main_module();
}
inline const ::torch::ModuleDef& ModelDef::main_module() const {
  const ::torch::ModuleDef* p = main_module_;
  // @@protoc_insertion_point(field_get:torch.ModelDef.main_module)
  return p != NULL ? *p : *reinterpret_cast<const ::torch::ModuleDef*>(
      &::torch::_ModuleDef_default_instance_);
}
inline ::torch::ModuleDef* ModelDef::release_main_module() {
  // @@protoc_insertion_point(field_release:torch.ModelDef.main_module)
  clear_has_main_module();
  ::torch::ModuleDef* temp = main_module_;
  main_module_ = NULL;
  return temp;
}
inline ::torch::ModuleDef* ModelDef::mutable_main_module() {
  set_has_main_module();
  if (main_module_ == NULL) {
    main_module_ = new ::torch::ModuleDef;
  }
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.main_module)
  return main_module_;
}
inline void ModelDef::set_allocated_main_module(::torch::ModuleDef* main_module) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete main_module_;
  }
  if (main_module) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      main_module = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, main_module, submessage_arena);
    }
    set_has_main_module();
  } else {
    clear_has_main_module();
  }
  main_module_ = main_module;
  // @@protoc_insertion_point(field_set_allocated:torch.ModelDef.main_module)
}

// optional string producer_name = 3;
inline bool ModelDef::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelDef::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelDef::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelDef::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& ModelDef::producer_name() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.producer_name)
  return producer_name_.GetNoArena();
}
inline void ModelDef::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.ModelDef.producer_name)
}
#if LANG_CXX11
inline void ModelDef::set_producer_name(::std::string&& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModelDef.producer_name)
}
#endif
inline void ModelDef::set_producer_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_producer_name();
  producer_name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModelDef.producer_name)
}
inline void ModelDef::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModelDef.producer_name)
}
inline ::std::string* ModelDef::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.producer_name)
  return producer_name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelDef::release_producer_name() {
  // @@protoc_insertion_point(field_release:torch.ModelDef.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelDef::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:torch.ModelDef.producer_name)
}

// optional string producer_version = 4;
inline bool ModelDef::has_producer_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelDef::set_has_producer_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelDef::clear_has_producer_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelDef::clear_producer_version() {
  producer_version_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_producer_version();
}
inline const ::std::string& ModelDef::producer_version() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.producer_version)
  return producer_version_.GetNoArena();
}
inline void ModelDef::set_producer_version(const ::std::string& value) {
  set_has_producer_version();
  producer_version_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.ModelDef.producer_version)
}
#if LANG_CXX11
inline void ModelDef::set_producer_version(::std::string&& value) {
  set_has_producer_version();
  producer_version_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModelDef.producer_version)
}
#endif
inline void ModelDef::set_producer_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_producer_version();
  producer_version_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModelDef.producer_version)
}
inline void ModelDef::set_producer_version(const char* value, size_t size) {
  set_has_producer_version();
  producer_version_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModelDef.producer_version)
}
inline ::std::string* ModelDef::mutable_producer_version() {
  set_has_producer_version();
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.producer_version)
  return producer_version_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelDef::release_producer_version() {
  // @@protoc_insertion_point(field_release:torch.ModelDef.producer_version)
  clear_has_producer_version();
  return producer_version_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelDef::set_allocated_producer_version(::std::string* producer_version) {
  if (producer_version != NULL) {
    set_has_producer_version();
  } else {
    clear_has_producer_version();
  }
  producer_version_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), producer_version);
  // @@protoc_insertion_point(field_set_allocated:torch.ModelDef.producer_version)
}

// optional string name = 5;
inline bool ModelDef::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelDef::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ModelDef::name() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.name)
  return name_.GetNoArena();
}
inline void ModelDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.ModelDef.name)
}
#if LANG_CXX11
inline void ModelDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModelDef.name)
}
#endif
inline void ModelDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModelDef.name)
}
inline void ModelDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModelDef.name)
}
inline ::std::string* ModelDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelDef::release_name() {
  // @@protoc_insertion_point(field_release:torch.ModelDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:torch.ModelDef.name)
}

// repeated .caffe2.Argument annotations = 6;
inline int ModelDef::annotations_size() const {
  return annotations_.size();
}
inline const ::caffe2::Argument& ModelDef::annotations(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.annotations)
  return annotations_.Get(index);
}
inline ::caffe2::Argument* ModelDef::mutable_annotations(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.annotations)
  return annotations_.Mutable(index);
}
inline ::caffe2::Argument* ModelDef::add_annotations() {
  // @@protoc_insertion_point(field_add:torch.ModelDef.annotations)
  return annotations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >*
ModelDef::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModelDef.annotations)
  return &annotations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >&
ModelDef::annotations() const {
  // @@protoc_insertion_point(field_list:torch.ModelDef.annotations)
  return annotations_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace torch

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::torch::ProtoVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::torch::ProtoVersion>() {
  return ::torch::ProtoVersion_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_caffe2_2fproto_2ftorch_2eproto__INCLUDED
